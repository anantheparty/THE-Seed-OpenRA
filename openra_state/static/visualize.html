<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenRA Zone Topology Visualization</title>
    <style>
        body { font-family: sans-serif; background: #222; color: #eee; margin: 0; padding: 20px; }
        #controls { margin-bottom: 10px; background: #333; padding: 10px; border-radius: 4px; }
        canvas { background: #000; border: 1px solid #555; cursor: crosshair; }
        #status { color: #aaa; font-size: 0.9em; margin-left: 10px; }
        .legend { display: inline-block; margin-left: 20px; font-size: 0.8em; }
        .legend span { display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; }
    </style>
</head>
<body>
    <div id="controls">
        <button onclick="fetchData()">Refresh Now</button>
        <label><input type="checkbox" id="autoRefresh" checked> Auto Refresh (2s)</label>
        <span id="status">Waiting...</span>
        <div class="legend">
            <span style="background:rgba(255,215,0,0.3)"></span>Ore
            <span style="background:rgba(0,255,255,0.3)"></span>Gem
            <span style="background:rgba(100,100,255,0.5)"></span>Zone
            <span style="border:1px solid #fff"></span>Link
        </div>
    </div>
    <canvas id="mapCanvas"></canvas>
    <div id="tooltip" style="position:absolute; background:#333; border:1px solid #fff; padding:5px; display:none; pointer-events:none;"></div>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const tooltip = document.getElementById('tooltip');
        
        let mapData = null;
        let scale = 10; // Pixels per cell

        canvas.addEventListener('mousemove', e => {
            if (!mapData) return;
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) / scale;
            const y = (e.clientY - rect.top) / scale;
            
            // Find closest zone
            let closest = null;
            let minDist = 5.0;
            
            for (const z of mapData.zones) {
                const dist = Math.sqrt((x - z.center.x)**2 + (y - z.center.y)**2);
                if (dist < z.radius && dist < minDist * 3) { // Check if inside radius
                    closest = z;
                    break; // Just pick first one
                }
            }

            if (closest) {
                tooltip.style.display = 'block';
                tooltip.style.left = e.pageX + 10 + 'px';
                tooltip.style.top = e.pageY + 10 + 'px';
                
                let combatInfo = "";
                if (closest.combat_strength) {
                    combatInfo += `<div style="margin-top:5px; border-top:1px solid #555; padding-top:2px;">`;
                    combatInfo += `<b>Combat Strength</b><br>`;
                    combatInfo += `<span style="color:#4f4">My: ${closest.combat_strength.my.toFixed(1)}</span> `;
                    combatInfo += `<span style="color:#f44">Enemy: ${closest.combat_strength.enemy.toFixed(1)}</span> `;
                    combatInfo += `<span style="color:#44f">Ally: ${closest.combat_strength.ally.toFixed(1)}</span>`;
                    combatInfo += `</div>`;
                    
                    // Helper to format unit list
                    const formatUnits = (units, color) => {
                        if (!units || Object.keys(units).length === 0) return "";
                        let html = `<div style="color:${color}; font-size:0.9em; margin-top:2px;">`;
                        for (const [name, count] of Object.entries(units)) {
                            html += `${name}:${count} `;
                        }
                        html += `</div>`;
                        return html;
                    };
                    
                    if (closest.units) {
                        combatInfo += formatUnits(closest.units.my, "#8f8");
                        combatInfo += formatUnits(closest.units.enemy, "#f88");
                        combatInfo += formatUnits(closest.units.ally, "#88f");
                    }
                    
                    if (closest.structures) {
                        combatInfo += `<div style="margin-top:2px; border-top:1px solid #555; padding-top:2px;"><b>Structures</b></div>`;
                        combatInfo += formatUnits(closest.structures.my, "#8f8");
                        combatInfo += formatUnits(closest.structures.enemy, "#f88");
                        combatInfo += formatUnits(closest.structures.ally, "#88f");
                    }
                }

                const visibilityText = closest.is_visible === null || typeof closest.is_visible === 'undefined' ? 'Unknown' : closest.is_visible;
                const exploredText = closest.is_explored === null || typeof closest.is_explored === 'undefined' ? 'Unknown' : closest.is_explored;
                tooltip.innerHTML = `
                    <b>Zone ${closest.id}</b><br>
                    Type: ${closest.type} (${closest.subtype})<br>
                    ResScore: ${closest.resource_value.toFixed(1)}<br>
                    Owner: ${closest.owner_faction || 'None'}<br>
                    Visible: ${visibilityText}<br>
                    Explored: ${exploredText}
                    ${combatInfo}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        });

        async function fetchData() {
            status.textContent = "Fetching...";
            try {
                const res = await fetch('/api/data');
                const data = await res.json();
                mapData = data;
                render();
                status.textContent = `Updated: ${new Date().toLocaleTimeString()} | Map: ${data.width}x${data.height}`;
            } catch (e) {
                status.textContent = "Error: " + e.message;
            }
        }

        function render() {
            if (!mapData) return;
            
            // Resize canvas
            canvas.width = mapData.width * scale;
            canvas.height = mapData.height * scale;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw Grid/Resources
            // Assuming resources are sent as list of points for efficiency or a grid
            // Here we assume raw grid is not sent, but maybe zones have info. 
            // Actually, let's visualize just the zones and clusters.
            
            // Draw Zones
            mapData.zones.forEach(z => {
                const cx = z.center.x * scale;
                const cy = z.center.y * scale;
                const r = z.radius * scale;
                
                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                
                // Color based on owner_faction or subtype
                if (z.owner_faction === '己方') {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; // Green for Self
                } else if (z.owner_faction === '友方') {
                    ctx.fillStyle = 'rgba(0, 100, 255, 0.4)'; // Blue for Ally
                } else if (z.owner_faction === '敌方') {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.4)'; // Red for Enemy
                } else if (z.owner_faction === '中立') {
                    ctx.fillStyle = 'rgba(128, 128, 128, 0.4)'; // Gray for Neutral
                } else {
                    // Fallback to resource type coloring if no owner
                    if (z.subtype === 'GEM') ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                    else if (z.subtype === 'ORE') ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
                    else ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
                }
                
                ctx.fill();
                ctx.strokeStyle = '#555';
                
                // Highlight MAIN_BASE
                if (z.type === 'MAIN_BASE') {
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#fff';
                } else {
                    ctx.lineWidth = 1;
                }
                ctx.stroke();
                
                // Draw ID
                ctx.fillStyle = '#fff';
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(z.id, cx, cy);
            });
            
            // Draw Connections
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            mapData.zones.forEach(z => {
                z.neighbors.forEach(nid => {
                    const neighbor = mapData.zones.find(nz => nz.id === nid);
                    if (neighbor && z.id < neighbor.id) { // Draw once
                        ctx.beginPath();
                        ctx.moveTo(z.center.x * scale, z.center.y * scale);
                        ctx.lineTo(neighbor.center.x * scale, neighbor.center.y * scale);
                        ctx.stroke();
                    }
                });
            });
        }

        setInterval(() => {
            if (document.getElementById('autoRefresh').checked) {
                fetchData();
            }
        }, 2000);
        
        // Initial load
        fetchData();
    </script>
</body>
</html>
